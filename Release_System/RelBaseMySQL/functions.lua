--[[##############################################################################	Модуль MySQL	Автор: Kingston	Версия: 1.0	API: API2	PtokaX 0.4.x.x, Lua 5.1		При поддержке: http://mydc.ru###################################################################################]]--	Основные функции--###################################################################################function ToUser(user,msg)	Core.SendToUser(user,"<"..tVar.sBot.."> "..msg.."|")endfunction PmToUser(user,msg)	Core.SendPmToUser(user,tVar.sBot,msg.."|")endfunction ToAll(msg)	Core.SendToAll("<"..tVar.sBot.."> "..msg.."|")endfunction ToOps(msg)	Core.SendToOps("<"..tVar.sBot.."> "..msg.."|")endfunction ToOpChat(msg)	Core.SendToOpChat(msg.."|")endfunction string:slice(from, len)    if (from + 0) < 0 then        from = (#self + from + 1);    elseif from == 0 then        from = 1;    end;    if not len then        len = #self;    elseif len <= 0 then        len = (#self + len + 1);    end;    return self:sub(from, len);end;function GetNormalShare(s,n)  local i,t=1,{"Б","КБ","МБ","ГБ","ТБ","ПБ"}  s=s and tonumber(s) or 0  n=n and "%."..n.."f " or "%.3f "  while s>0x400 do s,i=s/0x400,i+1 end  return n:format(s)..(t[i] or "??")endfunction OnTimer()	if tTimesToUpdate[os.date("%H:%M")] and tonumber(os.date("%S")) == 0 then		--ToOpChat("*** Текущее время: "..os.date("%H:%M:%S")..", пора обновлять базу релизов!")		--local iStart = os.clock()		LibTask.UpdBase();		LibTask.UpdStats();	end	CollectTrash();end-- MySQL Функцииstring.dbformat = function(self, ...)  local t = {...}  for k, v in ipairs(t) do    t[k] = tostring(v):gsub("(['\\\"])", "\\%1")  end  return self:format(unpack(t))endfunction string.sqlescape(str)	return str:gsub("\\","\\\\"):gsub("'","\\'")end--[[function CheckSQL()	if not conn or not conn:execute("USE "..tSql.DbName) then		conn = assert(env:connect(tSql.DbName,tSql.UserName,tSql.UserPass,tSql.Host,tSql.Port))		if conn then			conn:execute("SET NAMES "..tSql.Charset)			CreateTable()			return true		end	else		return true	endend]]--function CreateTable()		QuerySql("CREATE TABLE IF NOT EXISTS `rb_cat` ("..				"`id` tinyint(4) NOT NULL AUTO_INCREMENT,"..				"`name` tinytext CHARACTER SET "..tSql.Charset.." NOT NULL,"..				"`desc` tinytext CHARACTER SET "..tSql.Charset.." NOT NULL,"..				"`expire` INT(16) NOT NULL,"..				"`rels` tinyint(16) NOT NULL,"..				"PRIMARY KEY (`id`)"..				") ENGINE=MyISAM DEFAULT CHARSET="..tSql.Charset..";"				);		QuerySql("CREATE TABLE IF NOT EXISTS `rb_rels` ("..				"`id` int(10) unsigned NOT NULL AUTO_INCREMENT,"..				"`cat` int(10) unsigned NOT NULL,"..				"`num` int(10) unsigned NOT NULL,"..				"`name` text NOT NULL,"..				"`desc` text NOT NULL,"..				"`magnet` text NOT NULL,"..				"`date` date NOT NULL,"..				"`author` varchar(64) NOT NULL,"..				"`other_magnet` varchar(32) NOT NULL,"..				"PRIMARY KEY (`id`)"..				") ENGINE=MyISAM DEFAULT CHARSET="..tSql.Charset..";"				);		QuerySql("CREATE TABLE IF NOT EXISTS `rb_users` ("..				"`id` INT(16) NOT NULL AUTO_INCREMENT,"..				"`nick` VARCHAR(64) CHARACTER SET "..tSql.Charset.." NOT NULL ,"..				"`ip` VARCHAR(16) NOT NULL ,"..				"`status` VARCHAR(32) CHARACTER SET "..tSql.Charset.." NOT NULL ,"..				"PRIMARY KEY (`id`)"..				") ENGINE = MYISAM DEFAULT CHARSET="..tSql.Charset..";"				);		QuerySql("CREATE TABLE IF NOT EXISTS `rb_latest` ("..				"`id` INT( 16 ) NOT NULL AUTO_INCREMENT ,"..				"`cat` INT( 16 ) NOT NULL ,"..				"`rel` INT( 16 ) NOT NULL ,"..				"PRIMARY KEY ( `id` )"..				") ENGINE = MYISAM DEFAULT CHARSET="..tSql.Charset..";");end--[[function InitDB()	if CheckSQL() then		local cur = assert (conn:execute("SELECT `id` FROM `rb_cat`"));		local cats = cur:numrows();		cur:close();		local cur = assert (conn:execute("SELECT `id` FROM `rb_rels`"));		local rels = cur:numrows();		cur:close();		--local cur = assert (conn:execute("SELECT"))		return cats,rels	endend]]function SizeDB(cat)	if cat then		local cur = QuerySql("SELECT `num` FROM `rb_rels` WHERE `cat`='"..cat.."' ORDER BY `num` DESC LIMIT 1");		local row = cur:fetch ({}, "a")		while row do			str = row.num;			row = cur:fetch(row, "a");		end		cur:close();	else		local cur = QuerySql("SELECT * FROM `rb_cat`");		local row = cur:numrows();		while row do			str = tonumber(row);			row = cur:fetch (row, "a");		end		cur:close();	end	return strendfunction RelInfo(cat,rel)	if cat and rel then		local cur = QuerySql(("SELECT * FROM `rb_rels` WHERE `cat`='%s' AND `num`='%s'"):dbformat(cat,rel))		local row = cur:fetch ({}, "a");		while row do			--local str{};			str = row;			row = cur:fetch(row, "a");		end		cur:close();		return str	endendfunction CatInfo(cat)	if cat then		local cur = QuerySql(("SELECT * FROM `rb_cat` WHERE `num`='%s'"):dbformat(cat));		local row = cur:fetch ({}, "a");		while row do			str = row;			row = cur:fetch (row, "a");		end		cur:close();		return str	endendfunction QuerySql(query)	if CheckSQL() then		local r = assert(conn:execute(query));		return r	endend